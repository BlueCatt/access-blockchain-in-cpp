{"name":"Monero Examples","tagline":"access-blockchain-using-c++","body":"# Access blockchain information using C++\r\n\r\nHow to develop on top of [Monero](https://getmonero.org/)? One way is to use json-rpc calls from\r\nany language capable of this, for example, as\r\n[shown in python](http://moneroexamples.github.io/python-json-rpc/). Another way\r\nis to use pubilc api of existing Monero services such as\r\n [moneroblocks](http://moneroblocks.eu/api). Some Monero functions are even\r\n avaliable in JavaScript if you look at the source code of [mymonero.com](https://mymonero.com/#/).\r\n This  allows to develop some web applications with only HTML and JavaScript, such as,\r\n[XMR test](http://xmrtests.llcoins.net/checktx.html).\r\n\r\nThe other way, presented here, is to directly tap into Monero C++ libraries.\r\nHowever, there are no tutorials or any information how to do it.\r\n\r\nFor this reason this example was created, i.e.,  to show how to access Monero C++ libraries\r\nand do something with them.\r\n\r\nSmall disclaimer: I don't know if this is the correct way of doing\r\nthis, but it seems to be working. If something is done in a stupid or wrong way,\r\nor my explanations in the comments are incorrect, please let me know.\r\n\r\n# Objective\r\nThere's been a lot of talk in Monero about viewkeys. But how do you actually use them?\r\nWell, they can be used to to check which transaction's outputs in a given block belong to a given\r\naddress. Without the private viewkey associated with the given Monero address, it is not\r\npossible to check how much Monero there are in that address. The same, if we know that\r\na given transaction was sent to a specific address, it is not possible to check\r\nin a blockchain which outputs of that transaction actually were meant to belong to that address without\r\nthe private viewkey of that address. The viewkey allows to filter out outputs not bind to the address.\r\n\r\nChecking if any of a transaction's outputs are belong to a given address\r\nwith the private viewkey of that address is already possible using\r\n [XMR test](http://xmrtests.llcoins.net/checktx.html) website. This is very good,\r\n since it allows us to very the results obtained using this example with those\r\n provided by that website.\r\n\r\n\r\n# Pre-requsits\r\n\r\nEverthing here was done and tested on\r\nUbuntu 14.04 x86_64 and Ubuntu 15.10 x86_64.\r\n\r\nMine Monero node is using `lmdbq`, thus I use this database only in this example.\r\nI could not test on `berkeleydb`.\r\n\r\n## Dependencies\r\n\r\n\r\n```bash\r\n# refresh ubuntu's repository\r\nsudo apt-get update\r\n\r\n#install git\r\nsudo apt-get install git\r\n\r\n# install dependencies\r\nsudo apt-get install build-essential cmake libboost1.55-all-dev miniupnpc libunbound-dev graphviz doxygen libdb5.1++-dev\r\n```\r\n\r\n## Monero compilation\r\n\r\n\r\n```bash\r\n# download the latest bitmonero source code from github\r\ngit clone https://github.com/monero-project/bitmonero.git\r\n\r\n# go into bitmonero folder\r\ncd bitmonero/\r\n\r\nmake # or make -j number_of_threads, e.g., make -j 2\r\n```\r\n\r\n## Monero static libraries\r\nWhen the compilation finishes, a number of static Monero libraries\r\nshould be generated. We will need them to link against.\r\n\r\nSince they are spread around different subfolders of the `./build/` folder,\r\nit is easier to just copy them into one folder. I assume that\r\n `/opt/bitmonero-dev/libs` is the folder where they are going to be copied to.\r\n\r\n```bash\r\n# create the folder\r\nsudo mkdir -p /opt/bitmonero-dev/libs\r\n\r\n# find the static libraries files (i.e., those with extension of *.a)\r\n# and copy them to /opt/bitmonero-dev/libs\r\n# assuming you are still in bitmonero/ folder which got downloaded from\r\n# github\r\nsudo find ./build/ -name '*.a' -exec cp {} /opt/bitmonero-dev/libs  \\;\r\n ```\r\n\r\n## Monero headers\r\n\r\nNow we need to get Monero headers, as this is our interface to the\r\nMonero libraries. Folder `/opt/bitmonero-dev/headers` is assumed\r\nto hold the headers.\r\n\r\n```bash\r\n# create the folder\r\nsudo mkdir -p /opt/bitmonero-dev/headers\r\n\r\n# find the header files (i.e., those with extension of *.h)\r\n# and copy them to /opt/bitmonero-dev/headers\r\n# but this time the structure of directions is important\r\n# so rsync is used to find and copy the headers files\r\nsudo rsync -zarv --include=\"*/\" --include=\"*.h\" --exclude=\"*\" --prune-empty-dirs ./ /opt/bitmonero-dev/headers\r\n ```\r\n\r\n## cmake confing files\r\n`CMakeLists.txt` files and the structure of this project can be checked at\r\n[github](https://github.com/moneroexamples/access-blockchain-in-cpp).\r\nI wont be discussing them\r\nhere. I tried to put comments in `CMakeLists.txt` to clarify what is there.\r\n\r\nThe location of the Monero's headers and static libraries must be correctly\r\nindicated in `CMakeLists.txt`. So if you place them in different folders\r\nthat in this example, please change the root `CMakeLists.txt` file\r\naccordingly.\r\n\r\n# C++ code\r\nThe two most interesting C++ source files in this example are `MicroCore.cpp` and `main.cpp`.\r\nTherefore, I will present only these to files here. Full source code is\r\nat [github](https://github.com/moneroexamples/access-blockchain-in-cpp).\r\n\r\n## MicroCore.cpp\r\n\r\n`MicroCore` class is a micro version of [cryptonode::core](https://github.com/monero-project/bitmonero/blob/master/src/cryptonote_core/cryptonote_core.h) class. The core class is the main\r\nclass with the access to the blockchain that the Monero daemon is using.\r\nIn the `cryptonode::core` class, the most important method (at least for this example), is the [init](https://github.com/monero-project/bitmonero/blob/master/src/cryptonote_core/cryptonote_core.cpp#L206) method. The main goal of the `init` method\r\nis to create an instance of [Blockchain](https://github.com/monero-project/bitmonero/blob/master/src/cryptonote_core/blockchain.h) class. The `Blockchain` is the high level interface to blockchain database. The low level one is through `BlockchainLMDB` in our case, which\r\ncan also be accessed through the `Blockchain` object.\r\n\r\nThe original class does a lot of things, which we don't need here, such as reading program options. Thus its\r\nmicro version was prepared for this example.\r\n\r\n```c++\r\n#include \"MicroCore.h\"\r\n\r\nnamespace xmreg\r\n{\r\n    /**\r\n     * The constructor is interesting, as\r\n     * m_mempool and m_blockchain_storage depend\r\n     * on each other.\r\n     *\r\n     * So basically m_mempool is initialized with\r\n     * reference to Blockchain (i.e., Blockchain&)\r\n     * and m_blockchain_storage is initialized with\r\n     * reference to m_mempool (i.e., tx_memory_pool&)\r\n     *\r\n     * The same is done in cryptonode::core.\r\n     */\r\n    MicroCore::MicroCore():\r\n            m_mempool(m_blockchain_storage),\r\n            m_blockchain_storage(m_mempool)\r\n    {}\r\n\r\n\r\n    /**\r\n     * Initialized the MicroCore object.\r\n     *\r\n     * Create BlockchainLMDB on the heap.\r\n     * Open database files located in blockchain_path.\r\n     * Initialize m_blockchain_storage with the BlockchainLMDB object.\r\n     */\r\n    bool\r\n    MicroCore::init(const string& blockchain_path)\r\n    {\r\n        int db_flags = 0;\r\n\r\n        // MDB_RDONLY will result in\r\n        // m_blockchain_storage.deinit() producing\r\n        // error messages.\r\n\r\n        //db_flags |= MDB_RDONLY ;\r\n\r\n        db_flags |= MDB_NOSYNC;\r\n\r\n        BlockchainDB* db = nullptr;\r\n        db = new BlockchainLMDB();\r\n\r\n        try\r\n        {\r\n            // try opening lmdb database files\r\n            db->open(blockchain_path, db_flags);\r\n        }\r\n        catch (const std::exception& e)\r\n        {\r\n            cerr << \"Error opening database: \" << e.what();\r\n            return false;\r\n        }\r\n\r\n        // check if the blockchain database\r\n        // is successful opened\r\n        if(!db->is_open())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // initialize Blockchain object to manage\r\n        // the database.\r\n        return m_blockchain_storage.init(db, false);\r\n    }\r\n\r\n    /**\r\n    * Get m_blockchain_storage.\r\n    * Initialize m_blockchain_storage with the BlockchainLMDB object.\r\n    */\r\n    Blockchain&\r\n    MicroCore::get_core()\r\n    {\r\n        return m_blockchain_storage;\r\n    }\r\n\r\n\r\n    /**\r\n     * De-initialized Blockchain.\r\n     *\r\n     * Its needed to mainly deallocate\r\n     * new BlockchainDB object\r\n     * created in the MicroCore::init().\r\n     *\r\n     * It also tries to synchronize the blockchain.\r\n     * And this is the reason when, if MDB_RDONLY\r\n     * is set, we are getting error messages. Because\r\n     * blockchain is readonly and we try to synchronize it.\r\n     */\r\n    MicroCore::~MicroCore()\r\n    {\r\n        m_blockchain_storage.deinit();\r\n    }\r\n}\r\n```\r\n\r\n## main.cpp\r\nThis is the main file of the example. For the program to work, four\r\ninput values are required:\r\n\r\n - `address` - Monero adress.\r\n - `viewkey` - private view key associated with the address provided.\r\n - `txhash`  - transaction id (i.e., hash) which outputs we want to check.\r\n - `bc-path` - a path to lmdb folder with the blockchain.\r\n\r\nTo run the program, at least correct `bc-path` is required. All other\r\noptions have default values which work.\r\n\r\n```c++\r\n#include <iostream>\r\n#include <string>\r\n\r\n#include \"src/MicroCore.h\"\r\n#include \"src/CmdLineOptions.h\"\r\n#include \"src/tools.h\"\r\n\r\n\r\nusing namespace std;\r\nusing boost::filesystem::path;\r\nusing boost::filesystem::is_directory;\r\n\r\n// without this it wont work. I'm not sure what it does.\r\n// it has something to do with locking the blockchain and tx pool\r\n// during certain operations to avoid deadlocks.\r\nunsigned int epee::g_test_dbg_lock_sleep = 0;\r\n\r\n\r\nint main(int ac, const char* av[]) {\r\n\r\n    // get command line options\r\n    xmreg::CmdLineOptions opts {ac, av};\r\n\r\n    auto help_opt = opts.get_option<bool>(\"help\");\r\n\r\n    // if help was chosen, display help text and finish\r\n    if (*help_opt)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    // get other options\r\n    auto address_opt = opts.get_option<string>(\"address\");\r\n    auto viewkey_opt = opts.get_option<string>(\"viewkey\");\r\n    auto tx_hash_opt = opts.get_option<string>(\"txhash\");\r\n    auto bc_path_opt = opts.get_option<string>(\"bc-path\");\r\n\r\n\r\n    // default path to monero folder\r\n    // on linux this is /home/<username>/.bitmonero\r\n    string default_monero_dir = tools::get_default_data_dir();\r\n\r\n    // the default folder of the lmdb blockchain database\r\n    // is therefore as follows\r\n    string default_lmdb_dir   = default_monero_dir + \"/lmdb\";\r\n\r\n    // get the program command line options, or\r\n    // some default values for quick check\r\n    string address_str = address_opt ? *address_opt : \"48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU\";\r\n    string viewkey_str = viewkey_opt ? *viewkey_opt : \"1ddabaa51cea5f6d9068728dc08c7ffaefe39a7a4b5f39fa8a976ecbe2cb520a\";\r\n    string tx_hash_str = tx_hash_opt ? *tx_hash_opt : \"66040ad29f0d780b4d47641a67f410c28cce575b5324c43b784bb376f4e30577\";\r\n    path blockchain_path = bc_path_opt ? path(*bc_path_opt) : path(default_lmdb_dir);\r\n\r\n    if (!is_directory(blockchain_path))\r\n    {\r\n        cerr << \"Given path \\\"\" << blockchain_path   << \"\\\" \"\r\n             << \"is not a folder or does not exist\" << \" \"\r\n             << endl;\r\n        return 1;\r\n    }\r\n\r\n    blockchain_path.remove_trailing_separator();\r\n\r\n    // enable basic monero log output\r\n    uint32_t log_level = 0;\r\n    epee::log_space::get_set_log_detalisation_level(true, log_level);\r\n    epee::log_space::log_singletone::add_logger(LOGGER_CONSOLE, NULL, NULL);\r\n\r\n\r\n    // create instance of our MicroCore\r\n    xmreg::MicroCore mcore;\r\n\r\n    // initialize the core using the blockchain path\r\n    if (!mcore.init(blockchain_path.string()))\r\n    {\r\n        cerr << \"Error accessing blockchain.\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    // get the highlevel cryptonote::Blockchain object to interact\r\n    // with the blockchain lmdb database\r\n    cryptonote::Blockchain& core_storage = mcore.get_core();\r\n\r\n    // get the current blockchain height. Just to check\r\n    // if it reads ok.\r\n    uint64_t height = core_storage.get_current_blockchain_height();\r\n\r\n    cout << \"Current blockchain height: \" << height << endl;\r\n\r\n\r\n    // parse string representing given monero address\r\n    cryptonote::account_public_address address;\r\n\r\n    if (!xmreg::parse_str_address(address_str,  address))\r\n    {\r\n        cerr << \"Cant parse string address: \" << address_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // parse string representing of givenr private viewkey\r\n    crypto::secret_key prv_view_key;\r\n    if (!xmreg::parse_str_secret_key(viewkey_str, prv_view_key))\r\n    {\r\n        cerr << \"Cant parse view key: \" << viewkey_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // we also need tx public key, but we have tx hash only.\r\n    // to get the key, first, we obtained transaction object tx\r\n    // and then we get its public key from tx's extras.\r\n    cryptonote::transaction tx;\r\n\r\n    if (!xmreg::get_tx_pub_key_from_str_hash(core_storage, tx_hash_str, tx))\r\n    {\r\n        cerr << \"Cant find transaction with hash: \" << tx_hash_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    crypto::public_key pub_tx_key = cryptonote::get_tx_pub_key_from_extra(tx);\r\n\r\n    if (pub_tx_key == cryptonote::null_pkey)\r\n    {\r\n        cerr << \"Cant get public key of tx with hash: \" << tx_hash_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // public transaction key is combined with our viewkey\r\n    // to create, so called, derived key.\r\n    crypto::key_derivation derivation;\r\n\r\n    if (!generate_key_derivation(pub_tx_key, prv_view_key, derivation))\r\n    {\r\n        cerr << \"Cant get dervied key for: \" << \"\\n\"\r\n             << \"pub_tx_key: \" << prv_view_key << \" and \"\r\n             << \"prv_view_key\" << prv_view_key << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // lets check our keys\r\n    cout << \"\\n\"\r\n         << \"address          : <\" << xmreg::print_address(address) << \">\\n\"\r\n         << \"private view key : \"  << prv_view_key << \"\\n\"\r\n         << \"tx hash          : <\" << tx_hash_str << \">\\n\"\r\n         << \"public tx key    : \"  << pub_tx_key << \"\\n\"\r\n         << \"dervied key      : \"  << derivation << \"\\n\" << endl;\r\n\r\n\r\n    // each tx that we (or the address we are checking) received\r\n    // contains a number of outputs.\r\n    // some of them are ours, some not. so we need to go through\r\n    // all of them in a given tx block, to check which outputs are ours.\r\n\r\n    // get the total number of outputs in a transaction.\r\n    size_t output_no = tx.vout.size();\r\n\r\n    // sum amount of xmr sent to us\r\n    // in the given transaction\r\n    uint64_t money_transfered {0};\r\n\r\n    // loop through outputs in the given tx\r\n    // to check which outputs our ours. we compare outputs'\r\n    // public keys with the public key that would had been\r\n    // generated for us if we had gotten the outputs.\r\n    // not sure this is the case though, but that's my understanding.\r\n    for (size_t i = 0; i < output_no; ++i)\r\n    {\r\n        // get the tx output public key\r\n        // that normally would be generated for us,\r\n        // if someone had sent us some xmr.\r\n        crypto::public_key pubkey;\r\n\r\n        crypto::derive_public_key(derivation,\r\n                                  i,\r\n                                  address.m_spend_public_key,\r\n                                  pubkey);\r\n\r\n        // get tx output public key\r\n        const cryptonote::txout_to_key tx_out_to_key\r\n                = boost::get<cryptonote::txout_to_key>(tx.vout[i].target);\r\n\r\n\r\n        cout << \"Output no: \" << i << \", \" << tx_out_to_key.key;\r\n\r\n        // check if the output's public key is ours\r\n        if (tx_out_to_key.key == pubkey)\r\n        {\r\n            // if so, than add the xmr amount to the money_transfered\r\n            money_transfered += tx.vout[i].amount;\r\n            cout << \", mine key: \" << cryptonote::print_money(tx.vout[i].amount) << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << \", not mine key \" << endl;\r\n        }\r\n    }\r\n\r\n    cout << \"\\nTotal xmr received: \" << cryptonote::print_money(money_transfered) << endl;\r\n\r\n\r\n    cout << \"\\nEnd of program.\" << endl;\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n# Output example 1\r\nExecuting the program as follows:\r\n\r\n```bash\r\n./xmreg01 --address 48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU --viewkey 1ddabaa51cea5f6d9068728dc08c7ffaefe39a7a4b5f39fa8a976ecbe2cb520a --txhash 66040ad29f0d780b4d47641a67f410c28cce575b5324c43b784bb376f4e30577\r\n```\r\n\r\nResults in the following output:\r\n\r\n```bash\r\naddress          : <48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU>\r\nprivate view key : <1ddabaa51cea5f6d9068728dc08c7ffaefe39a7a4b5f39fa8a976ecbe2cb520a>\r\ntx hash          : <66040ad29f0d780b4d47641a67f410c28cce575b5324c43b784bb376f4e30577>\r\npublic tx key    : <0851f2ec7477b82618e028238164a9080325fe299dcf5f70f868729b50d00284>\r\ndervied key      : <8017f9944635b7b2e4dc2ddb9b81787e49b384dcb2abd474355fe62bee79fdd7>\r\n\r\nOutput no: 0, <c65ee61d95480988c1fd70f6078afafd4d90ef730fc3c4df59951d64136e911f>, not mine key\r\nOutput no: 1, <67a5fd7e06640942f0d869e494fc9d297d5087609013cd3531d0da55de19045b>, not mine key\r\nOutput no: 2, <a9e0f19422e68ed328315e92373388a3ebb418204a36d639bd1f2e870f4bc919>, mine key: 0.800000000000\r\nOutput no: 3, <849b56538f199f0a7522fcd0b132e53eec4a822e9b70b0e7e6c9e2632f1328db>, mine key: 4.000000000000\r\nOutput no: 4, <aba2e362f8ae0d79a4f33f9e4e27eecf79ad9c53eae86c27aa0281fb29aa6fdc>, not mine key\r\nOutput no: 5, <2602e4ac211216571ab1afe631aae1f905f252a1150cb8c4e5f34b820d0d6b4a>, not mine key\r\n\r\nTotal xmr received: 4.800000000000\r\n```\r\nThese results agree with those obtained using [XMR test](http://xmrtests.llcoins.net/checktx.html).\r\n\r\n# Output example 2\r\n\r\nExecuting the program as follows:\r\n\r\n```bash\r\n./xmreg01 --address 41vEA7Ye8Bpeda6g59v5t46koWrVn2PNgEKgzquJjmiKCFTsh9gajr8J3pad49rqu581TAtFGCH9CYTCkYrCpuWUG9GkgeB --viewkey fed77158ec692fe9eb951f6aeb22c3bda16fe8926c1aac13a5651a9c27f34309 --txhash ba807a90792f9202638e7288eff05949ccffbc54fd6a108571b65b963fee573a\r\n```\r\nResults in the following output:\r\n\r\n```bash\r\naddress          : <41vEA7Ye8Bpeda6g59v5t46koWrVn2PNgEKgzquJjmiKCFTsh9gajr8J3pad49rqu581TAtFGCH9CYTCkYrCpuWUG9GkgeB>\r\nprivate view key : <fed77158ec692fe9eb951f6aeb22c3bda16fe8926c1aac13a5651a9c27f34309>\r\ntx hash          : <ba807a90792f9202638e7288eff05949ccffbc54fd6a108571b65b963fee573a>\r\npublic tx key    : <70dd2b3a54dc153ab367d7bab9287db1e153053e02a5a273084da00344e11e59>\r\ndervied key      : <dad78e5ec247b91101cad60b98c09866cbcc46a3039c49a0de13be6e0645d8da>\r\n\r\nOutput no: 0, <460de8a6a3afea230c1a68db55054a67d2b33d80482cc5df645fed631d3b9c6e>, not mine key\r\nOutput no: 1, <54681e67463b5baf79a145ec90969ac0c1d358595e5a32c1e37e085290ee0dfe>, mine key: 0.080000000000\r\nOutput no: 2, <eb02627448c4cb2f21b3277f2a4359984cd89d0636a327ca068fe76f8d970bad>, mine key: 0.100000000000\r\nOutput no: 3, <584df4be03187e5545c6255cd61fee33afbdfa0b70fba2d9678cd43fd23f4df7>, not mine key\r\nOutput no: 4, <673f519e5a7e874485a5b239c54fc289941c7c15ad200f02d46ad98adfbd8049>, mine key: 9.000000000000\r\nOutput no: 5, <e1956d1077a9e5310c22a6a103e32f25def9aab4a7214894ed30a76d18cde271>, not mine key\r\n\r\nTotal xmr received: 9.180000000000\r\n```\r\n\r\nThese results agree also with those obtained using [XMR test](http://xmrtests.llcoins.net/checktx.html).\r\n\r\n#Output example 3\r\nExecuting the program as follows:\r\n```bash\r\n./xmreg01 --address 48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU --viewkey 1ddabaa51cea5f6d9068728dc08c7ffaefe39a7a4b5f39fa8a976ecbe2cb520a --txhash b82fe6d1f40e71a89a0c6d517ee1e84e4403870cba4589d0e6ca341ef966e143\r\n\r\n```\r\nResults in the following output:\r\n\r\n```bash\r\naddress          : <48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU>\r\nprivate view key : <1ddabaa51cea5f6d9068728dc08c7ffaefe39a7a4b5f39fa8a976ecbe2cb520a>\r\ntx hash          : <b82fe6d1f40e71a89a0c6d517ee1e84e4403870cba4589d0e6ca341ef966e143>\r\npublic tx key    : <99b7c2876e2058718c496f36656e459352d055101cb87827f60e75d60f632727>\r\ndervied key      : <cdac177a666eba391d5edc4f835e1e0d3e8f8735e322a0476b91e4d6e3a3a7f2>\r\n\r\nOutput no: 0, <2f1cf7db49a058592b58bdbb5a2121fb067f0be4fcd167936a242ad76fd7b32c>, mine key: 0.020000000000\r\nOutput no: 1, <0c37db67fd9cab5c3ce939df0a64905278ceb4520dde102c87f0bf66b1465aaa>, mine key: 0.100000000000\r\nOutput no: 2, <dbf1aac53547cc8ad8b288bdd83ae642aec2216fc647980e64e0a776a42b4267>, mine key: 9.000000000000\r\n\r\nTotal xmr received: 9.120000000000\r\n```\r\n\r\nThese results also agree with those obtained using [XMR test](http://xmrtests.llcoins.net/checktx.html).\r\n\r\n#Output example 4\r\nExecuting the program as follows:\r\n\r\n```bash\r\n./xmreg01 --address 41vEA7Ye8Bpeda6g59v5t46koWrVn2PNgEKgzquJjmiKCFTsh9gajr8J3pad49rqu581TAtFGCH9CYTCkYrCpuWUG9GkgeB --viewkey fed77158ec692fe9eb951f6aeb22c3bda16fe8926c1aac13a5651a9c27f34309 --txhash 60b6c42f1a3bea6ecf2adb8a4f98753be5a0a3e032a98beb7bdc44a325cea7e6\r\n```\r\n\r\nResults in the following output:\r\n\r\n```bash\r\naddress          : <41vEA7Ye8Bpeda6g59v5t46koWrVn2PNgEKgzquJjmiKCFTsh9gajr8J3pad49rqu581TAtFGCH9CYTCkYrCpuWUG9GkgeB>\r\nprivate view key : <fed77158ec692fe9eb951f6aeb22c3bda16fe8926c1aac13a5651a9c27f34309>\r\ntx hash          : <60b6c42f1a3bea6ecf2adb8a4f98753be5a0a3e032a98beb7bdc44a325cea7e6>\r\npublic tx key    : <c6e755802545f5444f095ab31be3c2aaca4500d0b016d34cc0953b37cb198a1d>\r\ndervied key      : <a6e57d6eed1c17cdb1da1b43ee0a4f49c2bfd2138d8da237f354f324712a67ba>\r\n\r\nOutput no: 0, <d58986ca9258cd4e4f7b0ef9baf3f61a49869364f5a9ec4a3d9186382a6b5110>, mine key: 0.020000000000\r\nOutput no: 1, <50fc47f931dfa393e369ab84a967c82dd866fd02205d656866dde9c2650329ca>, not mine key\r\nOutput no: 2, <55ea815f82a1552af2cf003b70f023bcde201ce3ad1ae8453ce9291b788d1cac>, mine key: 0.100000000000\r\nOutput no: 3, <e0d26e4d31022197d0831d3ba08b6b43e57672ccb9229880b29404468fd5984a>, not mine key\r\nOutput no: 4, <1ba3063bd57752537ca7ccd47ff2c0a72b7dcd8d8510fc222737636f208174cc>, mine key: 9.000000000000\r\n\r\nTotal xmr received: 9.120000000000\r\n```\r\nThese results agree also with those obtained using [XMR test](http://xmrtests.llcoins.net/checktx.html).\r\n\r\n## Compile this example\r\nThe dependencies are same as those for Monero, so I assume Monero compiles\r\ncorrectly. If so then to download and compile this example, the following\r\nsteps can be executed:\r\n\r\n```bash\r\n# download the source code\r\ngit clone https://github.com/moneroexamples/access-blockchain-in-cpp.git\r\n\r\n# enter the downloaded sourced code folder\r\ncd access-blockchain-in-cpp\r\n\r\n# create the makefile\r\ncmake .\r\n\r\n# compile\r\nmake\r\n```\r\n\r\nAfter this, `xmreg01` executable file should be present in access-blockchain-in-cpp\r\nfolder. How to use it, can be seen in the above example outputs.\r\n\r\n\r\n## How can you help?\r\n\r\nConstructive criticism, code and website edits are always good. They can be made through github.\r\n\r\nSome Monero are also welcome:\r\n```\r\n48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}