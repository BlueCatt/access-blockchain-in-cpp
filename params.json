{"name":"Monero Examples","tagline":"access-blockchain-in-cpp","body":"# access-blockchain-in-cpp\r\n\r\nHow to develop on top of monero? One way is to use josn-rpc calls from\r\nany language capable of this, for example, as\r\n[shown in python](http://moneroexamples.github.io/python-json-rpc/). Another way\r\nis to use pubilc api of existing monero services such as\r\n [moneroblocks](http://moneroblocks.eu/api). These to approaches can be useful,\r\n but they have limitations in that they allow for only a fraction of what\r\n monero can do. The reason is that most functionality of monero is available\r\n through C++11 libraries. Those can be difficult to navigate and use.\r\n\r\nFor this reason this example was created. To show can one can use c++ monero\r\nlibraries to write something that uses the wealthy of monero libraries and tools.\r\n\r\n# Objective\r\nTo check which transaction's outputs in a given block belong to a given\r\naddress. This is already possible using\r\n [XMR test](http://xmrtests.llcoins.net/checktx.html) website. And this is good,\r\n since it allows us to very results obtained this C++11 code with those\r\n provided by XMR test.\r\n\r\n\r\n# Pre-requsits\r\n\r\nEverthing here was done and tested on\r\nUbuntu 14.04 x86_64 and Ubuntu 15.10 x86_64.\r\n\r\nFor monero node is using `lmdbq`, thus I use this database only in this example.\r\nI could not test on `berkeleydb`, thus its not included here.\r\n\r\n## Dependencies\r\n\r\n\r\n```bash\r\n# refresh ubuntu's repository\r\nsudo apt-get update\r\n\r\n#install git\r\nsudo apt-get install git\r\n\r\n# install dependencies\r\nsudo apt-get install build-essential cmake libboost1.55-all-dev miniupnpc libunbound-dev graphviz doxygen libdb5.1++-dev\r\n```\r\n\r\n## Monero compilation\r\n\r\n\r\n```bash\r\n# download the latest bitmonero source code from github\r\ngit clone https://github.com/monero-project/bitmonero.git\r\n\r\n# go into bitmonero folder\r\ncd bitmonero/\r\n\r\nmake # or make -j number_of_threads, e.g., make -j 2\r\n```\r\n\r\n## Monero static libraries\r\nWhen the compilation finishes, bunch of static monero libraries\r\nshould be generated. We will need to link against.\r\n\r\nThey will be spread around different subfolders of the `./build/` folder.\r\nSo it is easier to just copy them into one folder. I assume that\r\n `/opt/bitmonero-dev/libs` will be our folder where we are going to keep them.\r\n\r\n```bash\r\n# create the folder\r\nsudo mkdir -p /opt/bitmonero-dev/libs\r\n\r\n# find the static libraries files (i.e., those with extension of *.a)\r\n# and copy them to /opt/bitmonero-dev/libs\r\n# assuming you are still in bitmonero/ folder which got downloaded from\r\n# github\r\nsudo find ./build/ -name '*.a' -exec cp {} /opt/bitmonero-dev/libs  \\;\r\n ```\r\n\r\n## Monero headers\r\n\r\nNow we need to get headers, as this is our interface to the\r\nmonero libraries.\r\n\r\n```bash\r\n# create the folder\r\nsudo mkdir -p /opt/bitmonero-dev/headers\r\n\r\n# find the header files (i.e., those with extension of *.h)\r\n# and copy them to /opt/bitmonero-dev/headers\r\n# but this time the structure of directions is important\r\n# so rsync is used to find and copy the headers files\r\nsudo rsync -zarv --include=\"*/\" --include=\"*.h\" --exclude=\"*\" --prune-empty-dirs ./ /opt/bitmonero-dev/headers\r\n ```\r\n\r\n## cmake confing files\r\n`CMakeLists.txt` files and the structure of this project are can be studied at github. I wont be discussing them\r\nhere. I tried to put comments in `CMakeLists.txt` to clarify what is there.\r\n\r\nThe location of the Monero's headers and static libraries must be correctly\r\nindicated in  `CMakeLists.txt`. So if you put them in different folder\r\nthat in this example, please change the root `CMakeLists.txt` file\r\nto reflect this.\r\n\r\n# C++11 code\r\nThe two most interesting C++11 source files in this example are `MicroCore.cpp` and `main.cpp`. Therefore, I will focus on them here.\r\nFull source code is on github.\r\n\r\n## MicroCore.cpp\r\n\r\n`MicroCore` class is a micro version of [cryptonode::core](https://github.com/monero-project/bitmonero/blob/master/src/cryptonote_core/cryptonote_core.h) class. The core class is the main\r\nclass with the access to the blockchain that the monero daemon is using. In the `cryptonode::core` class, the most important method (at least for this example), is the [init](https://github.com/monero-project/bitmonero/blob/master/src/cryptonote_core/cryptonote_core.cpp#L206) method. The main goal of the `init` function\r\nis to create instance of [Blockchain](https://github.com/monero-project/bitmonero/blob/master/src/cryptonote_core/blockchain.h) class. The `Blockchain` is the high level interface to blockchain. The low level one is through `BlockchainLMDB` in our case, which\r\ncan also be accessed through `Blockchain` object.\r\n\r\nThe original class does a lot of things, which we dont need here, such as reading program options, checking\r\nfile\r\n\r\n```c++\r\n#include \"MicroCore.h\"\r\n\r\nnamespace xmreg\r\n{\r\n    /**\r\n     * The constructor is interesting, as\r\n     * m_mempool and m_blockchain_storage depend\r\n     * on each other.\r\n     *\r\n     * So basically m_mempool initialized with\r\n     * reference to Blockchain (i.e., Blockchain&)\r\n     * and m_blockchain_storage is initialized with\r\n     * reference to m_mempool (i.e., tx_memory_pool&)\r\n     *\r\n     * The same is done in cryptonode::core.\r\n     */\r\n    MicroCore::MicroCore():\r\n            m_mempool(m_blockchain_storage),\r\n            m_blockchain_storage(m_mempool)\r\n    {}\r\n\r\n\r\n    /**\r\n     * Initialized the MicroCore object.\r\n     *\r\n     * Create BlockchainLMDB on the heap.\r\n     * Open database files located in blockchain_path.\r\n     * Initialize m_blockchain_storage with the BlockchainLMDB object.\r\n     */\r\n    bool\r\n    MicroCore::init(const string& blockchain_path)\r\n    {\r\n        int db_flags = 0;\r\n\r\n        // MDB_RDONLY will result in\r\n        // m_blockchain_storage.deinit() producing\r\n        // error messages.\r\n\r\n        //db_flags |= MDB_RDONLY ;\r\n\r\n        db_flags |= MDB_NOSYNC;\r\n\r\n        BlockchainDB* db = nullptr;\r\n        db = new BlockchainLMDB();\r\n\r\n        try\r\n        {\r\n            db->open(blockchain_path, db_flags);\r\n        }\r\n        catch (const std::exception& e)\r\n        {\r\n            cerr << \"Error opening database: \" << e.what();\r\n            return false;\r\n        }\r\n\r\n        if(!db->is_open())\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return m_blockchain_storage.init(db, false);\r\n    }\r\n\r\n    /**\r\n    * Get m_blockchain_storage.\r\n    * Initialize m_blockchain_storage with the BlockchainLMDB object.\r\n    */\r\n    Blockchain&\r\n    MicroCore::get_core()\r\n    {\r\n        return m_blockchain_storage;\r\n    }\r\n\r\n\r\n    /**\r\n     * De-initialized Blockchain.\r\n     *\r\n     * Its needed to mainly deallocate\r\n     * new BlockchainDB object\r\n     * created in the MicroCore::init().\r\n     *\r\n     * It also tries to synchronize the blockchain.\r\n     * And this is the reason when, if MDB_RDONLY\r\n     * is set, we are getting error messages. Because\r\n     * blockchain is readonly and we try to synchronize it.\r\n     */\r\n    MicroCore::~MicroCore()\r\n    {\r\n        m_blockchain_storage.deinit();\r\n    }\r\n\r\n}\r\n```\r\n\r\n## main.cpp\r\n\r\n```c++\r\n\r\n#include \"src/MicroCore.h\"\r\n#include \"src/tools.h\"\r\n\r\n\r\nusing namespace std;\r\n\r\nunsigned int epee::g_test_dbg_lock_sleep = 0;\r\n\r\nint main() {\r\n\r\n    // enable basic monero log output\r\n    uint32_t log_level = 0;\r\n    epee::log_space::get_set_log_detalisation_level(true, log_level);\r\n    epee::log_space::log_singletone::add_logger(LOGGER_CONSOLE, NULL, NULL); //LOGGER_NULL\r\n\r\n    // location of the lmdb blockchain\r\n    string blockchain_path {\"/home/mwo/.bitmonero/lmdb\"};\r\n\r\n    // input data: public address, private view key and tx hash\r\n    // they are hardcoded here, as I dont want to unnecessary\r\n    // bloat the code with parsing input arguments\r\n    string address_str {\"48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU\"};\r\n    string viewkey_str {\"1ddabaa51cea5f6d9068728dc08c7ffaefe39a7a4b5f39fa8a976ecbe2cb520a\"};\r\n    string tx_hash_str {\"66040ad29f0d780b4d47641a67f410c28cce575b5324c43b784bb376f4e30577\"};\r\n\r\n\r\n    // our micro cryptonote core\r\n    xmreg::MicroCore mcore;\r\n\r\n    if (!mcore.init(blockchain_path))\r\n    {\r\n        cerr << \"Error accessing blockchain.\" << endl;\r\n        return 1;\r\n    }\r\n\r\n    // get the high level cryptonote::Blockchain object to interact\r\n    // with the blockchain lmdb database\r\n    cryptonote::Blockchain& core_storage = mcore.get_core();\r\n\r\n    // get the current blockchain height. Just to check\r\n    // if it reads ok.\r\n    uint64_t height = core_storage.get_current_blockchain_height();\r\n\r\n    cout << \"Current blockchain height: \" << height << endl;\r\n\r\n\r\n\r\n    // parse string representing of monero address\r\n    cryptonote::account_public_address address;\r\n\r\n    if (!xmreg::parse_str_address(address_str,  address))\r\n    {\r\n        cerr << \"Cant parse string address: \" << address_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // parse string representing of our private viewkey\r\n    crypto::secret_key prv_view_key;\r\n    if (!xmreg::parse_str_secret_key(viewkey_str, prv_view_key))\r\n    {\r\n        cerr << \"Cant parse view key: \" << viewkey_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // we also need tx public key, rather than tx hash.\r\n    // to get it first, we obtained transaction object tx\r\n    // and then we get its public key from tx's extras.\r\n    cryptonote::transaction tx;\r\n\r\n    if (!xmreg::get_tx_pub_key_from_str_hash(core_storage, tx_hash_str, tx))\r\n    {\r\n        cerr << \"Cant find transaction with hash: \" << tx_hash_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    crypto::public_key pub_tx_key = cryptonote::get_tx_pub_key_from_extra(tx);\r\n\r\n    if (pub_tx_key == cryptonote::null_pkey)\r\n    {\r\n        cerr << \"Cant get public key of tx with hash: \" << tx_hash_str << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // public transaction key is combined with our view key\r\n    // to get so called, derived key.\r\n    crypto::key_derivation derivation;\r\n\r\n    if (!generate_key_derivation(pub_tx_key, prv_view_key, derivation))\r\n    {\r\n        cerr << \"Cant get dervied key for: \" << \"\\n\"\r\n             << \"pub_tx_key: \" << prv_view_key << \" and \"\r\n             << \"prv_view_key\" << prv_view_key << endl;\r\n        return 1;\r\n    }\r\n\r\n\r\n    // lets check our keys\r\n    cout << \"\\n\"\r\n         << \"address          : <\" << xmreg::print_address(address) << \">\\n\"\r\n         << \"private view key : \"  << prv_view_key << \"\\n\"\r\n         << \"tx hash          : <\" << tx_hash_str << \">\\n\"\r\n         << \"public tx key    : \"  << pub_tx_key << \"\\n\"\r\n         << \"dervied key      : \"  << derivation << \"\\n\" << endl;\r\n\r\n\r\n    // each tx that we (or the adddress we are checking) received\r\n    // contains a number of outputs.\r\n    // some of them are ours, some not. so we need to go through\r\n    // all of them in a given tx block, to check with outputs are ours.\r\n\r\n    // get the total number of outputs in a transaction.\r\n    size_t output_no = tx.vout.size();\r\n\r\n    // sum amount of xmr sent to us\r\n    // in the given transaction\r\n    uint64_t money_transfered {0};\r\n\r\n    // loop through outputs in the given tx\r\n    // to check which outputs our ours, we compare outputs\r\n    // public keys, with the public key that would had been\r\n    // generated for us.\r\n    for (size_t i = 0; i < output_no; ++i)\r\n    {\r\n        // get the tx output public key\r\n        // that normally would be generated for us,\r\n        // if someone send us some xrm\r\n        crypto::public_key pubkey;\r\n\r\n        crypto::derive_public_key(derivation,\r\n                                  i,\r\n                                  address.m_spend_public_key,\r\n                                  pubkey);\r\n\r\n\r\n        // get tx output public key\r\n        const cryptonote::txout_to_key tx_out_to_key\r\n                = boost::get<cryptonote::txout_to_key>(tx.vout[i].target);\r\n\r\n\r\n        cout << \"Output no: \" << i << \", \" << tx_out_to_key.key;\r\n\r\n        // check if the output's public key is ours\r\n        if (tx_out_to_key.key == pubkey)\r\n        {\r\n            // if so, than add the xmr amount to the money_transfered\r\n            money_transfered += tx.vout[i].amount;\r\n            cout << \", mine key: \" << cryptonote::print_money(tx.vout[i].amount) << endl;\r\n        }\r\n        else\r\n        {\r\n            cout << \", not mine key \" << endl;\r\n        }\r\n\r\n    }\r\n\r\n    cout << \"\\nTotal xmr received: \" << cryptonote::print_money(money_transfered) << endl;\r\n\r\n\r\n    cout << \"\\nEnd of program.\" << endl;\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n# Output\r\nThe main output is as follows:\r\n```bash\r\naddress          : <48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU>\r\nprivate view key : <1ddabaa51cea5f6d9068728dc08c7ffaefe39a7a4b5f39fa8a976ecbe2cb520a>\r\ntx hash          : <66040ad29f0d780b4d47641a67f410c28cce575b5324c43b784bb376f4e30577>\r\npublic tx key    : <0851f2ec7477b82618e028238164a9080325fe299dcf5f70f868729b50d00284>\r\ndervied key      : <8017f9944635b7b2e4dc2ddb9b81787e49b384dcb2abd474355fe62bee79fdd7>\r\n\r\nOutput no: 0, <c65ee61d95480988c1fd70f6078afafd4d90ef730fc3c4df59951d64136e911f>, not mine key\r\nOutput no: 1, <67a5fd7e06640942f0d869e494fc9d297d5087609013cd3531d0da55de19045b>, not mine key\r\nOutput no: 2, <a9e0f19422e68ed328315e92373388a3ebb418204a36d639bd1f2e870f4bc919>, mine key: 0.800000000000\r\nOutput no: 3, <849b56538f199f0a7522fcd0b132e53eec4a822e9b70b0e7e6c9e2632f1328db>, mine key: 4.000000000000\r\nOutput no: 4, <aba2e362f8ae0d79a4f33f9e4e27eecf79ad9c53eae86c27aa0281fb29aa6fdc>, not mine key\r\nOutput no: 5, <2602e4ac211216571ab1afe631aae1f905f252a1150cb8c4e5f34b820d0d6b4a>, not mine key\r\n\r\nTotal xmr received: 4.800000000000\r\n```\r\nThese results agree with those obtained using [XMR test](http://xmrtests.llcoins.net/checktx.html).\r\n\r\n## How can you help?\r\n\r\nConstructive criticism, code and website edits are always good. They can be made through github.\r\n\r\nSome Monero are also welcome:\r\n```\r\n48daf1rG3hE1Txapcsxh6WXNe9MLNKtu7W7tKTivtSoVLHErYzvdcpea2nSTgGkz66RFP4GKVAsTV14v6G3oddBTHfxP6tU\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}